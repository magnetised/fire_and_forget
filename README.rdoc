= Fire & Forget

Fire & Forget is a simple, framework agnostic, background task launcher for Ruby web apps.

What it does:

- Designed for infrequent calls to very long running operations
- Provides a mechanism for calling any external script from within a HTTP request
- Gives simple inter-process communication for status updates
- Launches long running tasks as completely independent processes so that you can restart/redeploy your application without interrupting any running tasks
- Provides a 'kill' mechanism so you can cancel your tasks

What it doesn't:

- Have any kind of queue mechanism. If you fire the same task twice then that task will be running twice
- Have any persistant state

== Quick Start


FAF works by running a simple TCP socket server so before we want to use it we have to start this server.

  $ fire_forget
  FAF process 16235 listening on 127.0.0.1:3001...

The service defaults to listening to port 3001 on localhost. You can change these values thus:

  $ fire_forget -a 192.168.1.22 -p 9090

If you do this you will need to set both the web-app and the tasks to use the right values using

  FireAndForget.port = 9090
  FireAndForget.bind_address = "192.168.1.22"

Now inside our Ruby app:

  require 'rubygems'
  require 'fire_and_forget'

  # First set register our task by giving it a name and a path to a script file
  FireAndForget.add_task(:long_running_task, "/path/to/script")

  # when we want to call the script we simple call #fire passing the name of the task and the options
  # we want to pass
  FireAndForget.fire(:long_running_task, {:param3 => "value3"})

  # Or, use the name as a method:
  FireAndForget.long_running_task({:param3 => "value3"})

This will result in the following command being exec'd in an independent process:

  /path/to/script --param3="value3"

It up to the script to parse and deal with the command line options.

Interprocess communication is relatively easy. Take the following as the source of the script "/path/to/script"

  #!/usr/bin/env ruby

  require 'rubygems'
  require 'fire_and_forget'

  # this will mix in the comms methods and map this task to the :long_running_task label
  # used in the calling script
  include FireAndForget::Daemon[:long_running_task]

  30.times do |i|
    # update our status. What you put here is up to you, but it should be a String
    set_task_status("#{i+1} of 30")
    sleep(1)
  end

Now in the client all we have to do to get the status for our task is:

  FireAndForget.get_status(:long_running_task)
  # => "18 of 30"

If we decided we've had enough then we can kill it:

  # Send "SIG_TERM" to our task
  FireAndForget.term(:long_running_task)

  # Or send any signal (see the Process.kill documentation)
  FireAndForget.kill(:long_running_task, "HUP")

== Security

F&F is intended to be run in a relatively trusted environment and by default only binds to localhost to stop external access. But to stop unintended access to system commands, only scripts belonging to the same user as the F&F server process are executed. This might not be enough so in the future I might add a limit on the locations of runnable scripts.


== Contributing to fire_and_forget

* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it
* Fork the project
* Start a feature/bugfix branch
* Commit and push until you are happy with your contribution
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

== Copyright

Copyright (c) 2010 Garry Hill. See LICENSE.txt for
further details.

